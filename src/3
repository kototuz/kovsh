#include "cmd.h"
#include <string.h>
#include <stdbool.h>
#include <stdio.h>


static Cmd *findCmdByName(Cmdline *cmdline, char *cmdName) {
    size_t cmdsLen = cmdline->config.cmdList.len;
    for (size_t i = 0; i < cmdsLen; i++) {
        if (strcmp(cmdline->config.cmdList.items[i].name, cmdName) == 0) {
            return &cmdline->config.cmdList.items[i];
        }
    }

    return NULL;
}

static CmdArg *findCmdArgByName(Cmd *cmd, const char *argName) {
    size_t argListLen = cmd->callback.argList.len;
    for (size_t i = 0; i < argListLen; i++) {
        if (strcmp(cmd->callback.argList.items[i].name, argName) == 0) {
            return &cmd->callback.argList.items[i];
        }
    }

    return NULL;
}


typedef struct {
    char *data;
    size_t dataLen;
    char *cursor;
} Lexer;

typedef enum {
    TOKEN_DELIM_BEG,
    TOKEN_DELIM_END,
    TOKEN_DELIM_BEG_END,
    TOKEN_SYMBOL,
    TOKEN_EQ,
    TOKEN_INVALID,
} TokenType;

typedef struct {
    TokenType type;
    char *data;
    size_t dataLen;
} Token;

typedef struct {
    size_t len;
    Token *items;
} TokenSeq;

static Lexer lexerNew(char *data, size_t dataLen) {
    return (Lexer) {
        .data = data,
        .dataLen = dataLen,
        .cursor = data
    };
}

static void lexerTrim(Lexer *self) {
    while (*self->cursor == ' ') {
        self->cursor++;
    }
}

static TokenType lexerTokenType(int letter) {
    if ((letter > 'a' && letter < 'z') ||
        (letter > 'A' && letter < 'Z') ||
        (letter > '0' && letter < '9')) {
        return TOKEN_SYMBOL;
    }

    switch (letter) {
        case '\'':
        case '"':
            return TOKEN_DELIM_BEG_END;

        case '(':
        case '[':
        case '{':
        case '<':
            return TOKEN_DELIM_BEG;

        case ')':
        case ']':
        case '}':
        case '>':
            return TOKEN_DELIM_END;

        case '=':
            return TOKEN_EQ;
    }
    return TOKEN_INVALID;
}

static bool isSymbol(int letter) {
    if ((letter > 'a' && letter < 'z') ||
        (letter > 'A' && letter < 'Z') ||
        (letter > '0' && letter < '9')) {
        return true;
    }

    return false;
}

static Token lexerNextToken(Lexer *self) {
    lexerTrim(self);

    Token token = {0};
    token.type = lexerTokenType(*self->cursor);
    token.data = self->cursor;
    token.dataLen = 1;

    if (token.type == TOKEN_SYMBOL) {
        self->cursor++;
        while (isSymbol(*self->cursor)) {
            self->cursor++;
            token.dataLen++;
        }
        return token;
    }

    self->cursor++;

    return token;
}

int main(void) {
    char *text = "Hello, World";
    Lexer l = lexerNew(text, strlen(text));

    Token token = lexerNextToken(&l);
    while (token.type != TOKEN_INVALID) {
        for (size_t i = 0; i < token.dataLen; i++) {
            putchar(token.data[i]);
        }
        putchar('\n');
        token = lexerNextToken(&l);
    }

    return 0;
}
//
//#define PAIRS_LEN 6
//const char pairSymbols[] = {
//    '"', '"',
//    '\'', '\'',
//    '(', ')',
//    '[', ']',
//    '{', '}',
//    '<', '>'
//};
//
//static int nextCmdArgToken(CmdArgToken *token, char **string) {
//    char *strCopy = *string;
//    while (*strCopy == ' ') {
//        strCopy++;
//    }
//
//    if (*strCopy == '\0') return 0;
//
//    char *tokenArgNamePtr = strCopy;
//
//    char *tokenAssignOperatorPtr = strchr(tokenArgNamePtr, '=');
//    if (tokenAssignOperatorPtr == NULL) {
//        fputs("ERROR: the assign operator `=` was missed", stderr);
//        return -1;
//    }
//
//    *tokenAssignOperatorPtr = '\0';
//    *(tokenArgNamePtr + strcspn(tokenArgNamePtr, " ")) = '\0';
//
//    tokenAssignOperatorPtr++;
//    while (*tokenAssignOperatorPtr == ' ') {
//        tokenAssignOperatorPtr++;
//    }
//
//    if (*tokenAssignOperatorPtr == '\0') {
//        fputs("ERROR: the arg was missed", stderr);
//        return -1;
//    }
//
//    char *tokenLastSymbol;
//    for (size_t i = 0, y = 0; i < PAIRS_LEN; i++, y += 2) {
//        if (*tokenAssignOperatorPtr == pairSymbols[y]) {
//            tokenAssignOperatorPtr++;
//            tokenLastSymbol = strchr(tokenAssignOperatorPtr, pairSymbols[y+1]);
//            if (tokenLastSymbol == NULL) {
//                fputs("ERROR: the end pair symbol is missed", stderr);
//                return -1;
//            }
//            goto ok;
//        }
//    }
//
//    tokenLastSymbol = tokenAssignOperatorPtr + strcspn(tokenAssignOperatorPtr, " ");
//
//ok:
//    *tokenLastSymbol = '\0';
//    *string = tokenLastSymbol + 1;
//
//    token->name = tokenArgNamePtr;
//    token->valString = tokenAssignOperatorPtr;
//
//    return 1;
//}
//
//static int cmdParseString(Cmdline *cmdline, char *string) {
//    Cmd *cmd = findCmdByName(strtok(string, " "));
//}
//
//// TEST
//int main(void) {
//    char str[] = "arg1='Hello, World' arg2={Maybe} arg3 =     'What is it?'";
//    char *str_p = str;
//
//    CmdArgToken token;
//    while (nextCmdArgToken(&token, &str_p)) {
//        printf("token = [name: %s, valString: %s]\n", token.name, token.valString);
//    }
//
//    return 0;
//}
//
////static void getCmdArgValueBorders(CmdArgParseInfo parseInfo,
////                                  char *beginString,
////                                  char **outBegin,
////                                  char **outEnd) {
////    *outBegin = parseInfo.beginSign == 0 ?
////                beginString :
////                strchr(beginString, parseInfo.beginSign);
////
////    if (*outBegin == NULL) return;
////
////    char *valueEnd;
////    if (parseInfo.endSign == 0) {
////        valueEnd = *outBegin;
////        while (*valueEnd != ' ' && *valueEnd != '\0') {
////            valueEnd++;
////        }
////    } else {
////        valueEnd = strchr(*outBegin, parseInfo.endSign);
////    }
////
////    *outEnd = valueEnd;
////}
//
////
////static int parseCmdArgs(Cmd *cmd, char *argsString) {
////    for (;;) {
////        if (*argsString == '\0') break;
////
////        char *assignOperator = strchr(argsString, '=');
////        if (assignOperator == NULL) {
////            fprintf(stderr, "ERROR: the argument assignment operator `=` was expected\n");
////            return -1;
////        }
////
////        *assignOperator = '\0';
////        CmdArg *cmdArg = findCmdArgByName(cmd, argsString);
////        if (cmdArg == NULL) {
////            fprintf(stderr, "ERROR: the argument `%s` does not exist\n", argsString);
////            return -1;
////        }
////
////        char *argValueBegin;
////        char *argValueEnd;
////        getCmdArgValueBorders(cmdArg->parseInfo,
////                              ++assignOperator,
////                              &argValueBegin,
////                              &argValueEnd);
////
////        if (argValueBegin == NULL || argValueEnd == NULL) {
////            fprintf(stderr, "ERROR: the argument value borders were expected");
////            return -1;
////        }
////
////        cmdArg->parseInfo.parser(cmdArg, argValueBegin);
////
////        if (argValueEnd == ' ') *argValueEnd++ = '\0';
////        argsString = argValueEnd;
////    }
////}
////
////static int parseCmdlineString(const char *cmdline) {
////    Cmd *cmd = findCmdByName(strtok(cmdline, " "));
////    if (cmd == NULL) {
////        fprintf(stderr, "ERROR: the cmd does not exist");
////        return -1;
////    }
////
////    if (!parseCmdArgs(cmd, cmdline)) return -1;
////}
